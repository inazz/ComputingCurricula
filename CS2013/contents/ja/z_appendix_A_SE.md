
# ソフトウェア工学 (SE)


すべてのコンピューティングアプリケーション分野において、専門性、品質、スケジュール、コストはソフトウェアシステムの生産において重要です。このため、ソフトウェア工学の要素は、コンピューティングのすべての分野でソフトウェアを開発する際に適用可能です。ソフトウェア工学の規律が最初に認識される必要があって以来、様々なソフトウェア工学の実践が開発され、利用されてきました。これらの異なる実践の間の多くのトレードオフも特定されてきました。実践的なソフトウェアエンジニアは、開発労力から引き出される価値を最大化するために、適切な技術と慣習を選択し適用しなければなりません。これをどのように行うかを学ぶために、彼らはソフトウェア工学の要素を学習します。

ソフトウェア工学は、顧客やユーザーの要求を満足させる信頼性のあるソフトウェアシステムを効果的かつ効率的に構築するための理論、知識、実践の応用に関心を持つ学問分野です。この分野は、小規模、中規模、大規模なシステムに適用可能です。また、ソフトウェアシステムのライフサイクル全体、すなわち要求の抽出、分析と仕様化、設計、構築、検証と妥当性確認、展開、運用と保守を包括します。小規模であろうと大規模であろうと、伝統的な計画主導型の開発プロセスを採用しようと、アジャイルなアプローチを採用しようと、あるいはその他の方法を採用しようと、ソフトウェア工学は優れたソフトウェアシステムを構築する最善の方法について関心を持っています。

ソフトウェア開発においては、工学的手法、プロセス、技術、および測定を用います。また、様々なツール (ソフトウェア開発の管理、ソフトウェア成果物の分析とモデリング、品質の評価と制御、そしてソフトウェアの進化と再利用に対する規律ある制御されたアプローチを確保するためのツール) の利用から利益を得ています。ソフトウェア工学のツールボックスは年々進化しています。たとえば、文節やクラスの不変条件を要求・確保する契約の使用は、より一般的になっている良い実践の1つです。ソフトウェア開発は、個々の開発者や開発者のチーム、あるいは複数チームが関与するため、指定された開発環境に対する最も適したツール、方法、アプローチを選択する必要があります。

学生と教員は、専門性がソフトウェア工学のアプローチにどのような影響を与えるかを理解する必要があります。例えば、特化したシステムには以下のようなものがあります：

* リアルタイムシステム
* クライアントサーバーシステム
* 分散システム
* 並列システム
* Webベースのシステム
* 高信頼性システム
* ゲーム
* モバイルコンピューティング
* ドメイン特化型ソフトウェア（例えば、科学計算やビジネスアプリケーションなど）

これらの特化したシステムそれぞれが提起する問題は、ソフトウェア工学の各フェーズで特定の処理を要求します。学生は、一般的なソフトウェア工学の技術と原則と、特化したシステム特有の問題に対処するための技術と原則との違いを認識する必要があります。

ソフトウェア工学の応用を教える際には、専門性が与える重要な影響として異なる題材の選択が必要になる場合があります (異なるプロセスモデル、システムのモデル化への異なるアプローチ、あるいは主要な活動を実行するための技術の異なる選択など)。これは、コアと選択的な教材の割り当てに反映されており、コアのトピックと学習到達目標は、様々な選択肢の根底にある原則に焦点を当て、選択肢を決定するための様々な代替案の詳細は選択的な題材に割り当てられています。

ソフトウェア工学の実践における別の分類は、システムが正確に必要な機能を実装するための基本的な必要性に関心があるか、システムの他の品質やそれらの品質をバランスさせるためのトレードオフに関心があるかです。この区分もまた、コアと選択的な題材の割り当てに反映されており、そのようなシステムを開発するための基本的な方法に関心を持つトピックと学習到達目標はコアに、他の品質やそれらの間のトレードオフに関心を持つものは選択的な題材に割り当てられます。

一般的に、学生がこのソフトウェア工学の知識領域で定義された題材の多くを使用する最善の方法は、プロジェクトに参加することです。学生はチームで作業し、ソフトウェアシステムのライフサイクルを可能な限り幅広く開発し経験するべきです。ソフトウェア開発の大部分は、チームメンバーやステークホルダーとの効果的なコミュニケーションに費やされます。プロジェクトチームを通じることで、プロジェクトは学生が効果的なソフトウェア工学の技術を使用し、コミュニケーションスキルを開発し実践するという十分な挑戦を与えることができます。効果的なプロジェクトを学術的な枠組みの中で組織し運営することは困難かもしれませんが、プロジェクトの実践環境こそがソフトウェア工学の理論と知識の適用を学ぶ最善の方法です。本文書でいくつかの知識単位に指定されている最小時間は、関連する応用レベルの学習成果を達成するには不十分に見えるかもしれません。これらの成果は、知識単位内のトピックが紹介されるよりも後のカリキュラムでさえ、プロジェクトの経験を通じて達成されるべきであると理解すべきです。

さらに、学生がソフトウェア工学の本質をより効果的に適用する方法を学ぶ上で、反復的なアプローチが有効であるという証拠が増えています。このアプローチでは、学生は開発サイクルを経験し、自分たちの仕事を評価し、その評価を通じて得た知識を別の開発サイクルに適用する機会があります。アジャイルおよび反復的なライフサイクルモデルは、本質的にそのような機会を提供します。

本文書におけるソフトウェアライフサイクルの用語は、Software Engineering Body of Knowledge (SWEBOK) や ACM/IEEE-CS Software Engineering 2004 Curriculum Guidelines (SE2004) などの早期の資料で使用されているものに基づいています。いくつかの用語はもともと計画主導型の開発プロセスの文脈で定義されましたが、ここでは一般的な用語として扱い、アジャイルなプロセスにも等しく適用します。


注意: [SDF/開発方法](./z_appendix_A_SDF.md#sdf開発方法) の知識単位には、ソフトウェア工学の特定の側面を紹介するための9時間の必修が含まれています。このソフトウェア工学の知識領域の知識単位、トピック、およびコア時間の仕様は、[SDF/開発方法](./z_appendix_A_SDF.md#sdf開発方法)で説明されている題材はすでに履修済みと前提しています。


**SE. ソフトウェア工学 (必修 6時間, 選択必修 21時間)**

| 知識単位 | 必修時間 | 選択必修時間 | 含選択科目 |
| -------- | -------- | ------------ | ---------- |
| SE/ソフトウェアプロセス                 | 2 | 1 | Y |
| SE/ソフトウェアプロジェクトマネジメント |   | 2 | Y |
| SE/ツールと環境                         |   | 2 | N |
| SE/要求工学                             | 1 | 3 | Y |
| SE/ソフトウェア設計                     | 3 | 5 | Y |
| SE/ソフトウェアの構築                   |   | 2 | Y |
| SE/ソフトウェアの検証と妥当性確認       |   | 4 | Y |
| SE/ソフトウェア進化・発展               |   | 2 | Y |
| SE/ソフトウェアの信頼性                 |   | 1 | Y |
| SE/形式手法                             |   |   | Y |



## SE/ソフトウェアプロセス
*[必修 2時間, 選択必修 1時間]*

**トピック:**

[必修]

* システムレベルの考慮事項、つまり、ソフトウェアと想定環境との相互作用 (相互参照: [IAS/安全なソフトウェア工学](./z_appendix_A_IAS.md#ias安全なソフトウェア工学))
* ソフトウェアプロセスモデルの紹介 (例: ウォーターフォール, インクリメンタル, アジャイル)
 * ソフトウェアライフサイクル内の活動
* 大人数でのプログラミングと個人のプログラミング

[選択必修]

* ソフトウェアプロセスモデルの評価

[選択科目]

* ソフトウェア品質の概念
* プロセス改善
* ソフトウェアプロセス能力成熟度モデル
* ソフトウェアプロセスの測定

**学習到達目標:**

[必修]

1. ソフトウェアがさまざまなシステム (情報管理、組み込み、工程管理、通信システムなど)とどのように関わり相互作用するかを説明する。[知識]
2. ウォーターフォール、イテレーティブ、アジャイルなど、いくつかの主要なプロセスモデルの相対的な利点と欠点を説明する。[知識]
3. さまざまなプロセスモデルの主要な構成要素である異なる実践を説明する。[知識]
4. ソフトウェア開発のフェーズを区別する。[知識]
5. 大規模なコードベースの理解、コードの読み取り、ビルドの理解、変更の文脈の理解について、大規模なプログラミングが個人開発とどのように異なるかを説明する。[知識]

[選択必修]

6. ソフトウェアライフサイクルの概念を説明し、その例を挙げ、各フェーズをフェーズ毎の成果物を含めて説明する。[知識]
7. 要求の安定性、サイズ、非機能特性などの問題を考慮に入れて、特定の種類のソフトウェアシステムの開発に対するいくつかの一般的なプロセスモデルの価値を比較する。[使用]

[選択科目]

8. ソフトウェア品質を定義し、品質保証活動がソフトウェアプロセスにおいて果たす役割を説明する。[知識]
9. 複数のプロセス改善アプローチの目的と基本的な類似点を説明する。[知識]
10. CMM、CMMI、CQI、Plan-Do-Check-Act、ISO9000などのいくつかのプロセス改善モデルを比較する。[評価]
11. プロセス改善（PSPなどのモデルを使用）やプロジェクトの振り返りを通じて、開発の取り組みを評価し、取りうる変更を推奨する。[使用]
12. プロセス改善におけるプロセス成熟度モデルの役割を説明する。[知識]
13. プロジェクトを評価し、制御するためのいくつかのプロセス指標を説明する。[知識]
14. プロジェクト指標を使用してプロジェクトの現状を説明する。[使用]



## SE/ソフトウェアプロジェクトマネジメント
*[選択必修 2時間]*

**トピック:**

[選択必修]

* チーム参加
 * タスクの責任、ミーティング構造、および作業スケジュールに関するチームプロセス
 * ソフトウェアチームにおける役割と責任
 * チームの対立解決
 * 仮想チームに関連するリスク（コミュニケーション、認識、構造）
* 工数見積もり（個人レベルで）
* リスク（[IAS/安全なソフトウェア工学](./z_appendix_A_IAS.md#ias安全なソフトウェア工学)を参照）
 * ライフサイクルにおけるリスクの役割
 * セキュリティ、安全性、市場、財務、技術、人々、品質、構造、プロセスを含むリスクカテゴリー

[選択科目]

* チームマネジメント
 * チーム組織と意思決定
 * 役割の識別と割り当て
 * 個人とチームのパフォーマンス評価
* プロジェクトマネジメント
 * スケジューリングと追跡
 * プロジェクトマネジメントツール
 * 費用便益分析
* ソフトウェアの測定と見積もり技術
* ソフトウェア品質保証と測定の役割
* リスク
 * リスクの識別と管理
 * リスク分析と評価
 * リスク許容度（例えば、リスク回避、リスク中立、リスク追求）
 * リスクプランニング
* ツールに潜む危険を含む、システム全体観点からのリスクへのアプローチ

**学習到達目標:**

[選択必修]

1. チームの効果的な機能に寄与する一般的な行動を議論する。[知識]
2. チームミーティングの議題を作成し、それに従う。[使用]
3. ソフトウェア開発チームに必要な役割を特定し、その理由を示す。[使用]
4. チームの対立の源泉、危険性、および潜在的な利点を理解する。[使用]
5. チームの状況で対立解決戦略を適用する。[使用]
6. アドホックな方法を使用してソフトウェア開発の工数 (例えば、時間) を見積もり、実際に必要な工数と比較する。[使用]
7. ソフトウェアリスクのいくつかの例を挙げる。[知識]
8. ソフトウェア開発ライフサイクルにおけるリスクの影響を説明する。[知識]
9. ソフトウェアシステムのリスクの異なるカテゴリーを説明する。[知識]

[選択科目]

10. チームプロジェクトに参加することにより、チームビルディングとチーム管理の中心的な要素を実演する。[使用]
11. プロセスモデルの選択がチーム組織構造と意思決定プロセスにどのように影響するか説明する。[知識]
12. 適切な役割を特定し、チームメンバーに役割を割り当てることでチームを組成する。[使用]
13. チームのおかれた環境で、チームや個々のパフォーマンスを評価し、フィードバックを提供する。[使用]
14. 特定のソフトウェアプロセスを使用して、計画および監視が必要なプロジェクトの側面（例えば、規模と工数の見積もり、スケジュール、リソースの割り当て、構成管理、変更管理、プロジェクトのリスクの特定と管理）を説明する。[知識]
15. 適切なプロジェクトの測定基準を使用して、プロジェクトのある段階の進行状況を追跡する。[使用]
16. 単純なソフトウェアの規模とコストの見積もり技術を比較する。[使用]
17. プロジェクト管理ツールを使用して、ソフトウェア開発プロジェクトでのタスクの割り当てと追跡を支援する。[使用]
18. リスク許容度がソフトウェア開発プロセスにどのように影響するか説明する。[評価]
19. リスクを特定し、リスク管理のアプローチ（回避、受け入れ、転嫁、軽減）を説明し、それぞれの長所と短所を特徴づける。[知識]
20. リスクがソフトウェア開発プロセス上の意思決定にどのように影響するか説明する。[使用]
21. ソフトウェアシステムのセキュリティリスクを特定する。[使用]
22. 特定の状況での危険の原因と可能性の特定に系統的なアプローチを示す。[使用]
23. セキュリティの状況を含むさまざまな単純なシナリオでリスク管理の基本的な原則を適用する。[使用]
24. リスク軽減アプローチのための費用便益分析を行う。[使用]
25. ソフトウェア以外の側面から生じる全体のシステムのリスクを特定し、分析する。[使用]



## SE/ツールと環境
*[選択必修 2時間]*

**トピック:**

* ソフトウェア構成管理とバージョン管理
* リリース管理
* 要求分析と設計モデリングツール
* 静的および動的解析ツールを含むテストツール
* プログラム構築プロセスの一部を自動化するプログラミング環境 (例: 自動ビルド)
 * 継続的インテグレーション
* ツール統合の概念とメカニズム

**学習到達目標:**

1. 集中型と分散型のソフトウェア管理の違いを説明する。[知識]
2. バージョン管理がソフトウェアのリリース管理をどのように支援するかを説明する。[知識]
3. 小規模チームのプロジェクトで、構成品目を特定し、ソースコード管理ツールを使用する。[使用]
4. 利用可能な静的・動的テストツールがどのようにソフトウェア開発環境に統合されるかを説明する。[知識]
5. 特定のソフトウェアシステムの開発に必要なツールセットを選択する際の重要な論点を説明する。これには、要求追跡、設計モデリング、実装、ビルド自動化、およびテストのツールが含まれる。[知識]
6. 中規模のソフトウェア製品の開発を支援するためのソフトウェアツールを使用する能力を示す。[使用]



## SE/要求工学
*[必修 1時間, 選択必修 3時間]*

ソフトウェアシステムに関連するニーズ、優先事項、制約についての共通の理解を醸成することが要求工学の目的です。多くのソフトウェアの失敗は、開発すべきソフトウェアの要求の理解が不完全であるか、またはそれらの要求の管理が不適切であるために発生します。

要求仕様は、完全に非公式 (たとえば、話し言葉) から厳密に数学的 (たとえば、Z言語や一階述語論理のような仕様記述言語) までの形式で範囲が異なります。実際には、成功したソフトウェア開発の取り組みでは、要求仕様を用いて曖昧さを減らし、開発チームのソフトウェアの展望についての理解の一貫性と完全性を向上させます。計画主導のアプローチでは、番号付きの要件を含む公式のドキュメントを作成する傾向があります。アジャイルなアプローチでは、ユーザーストーリー、ユースケース、テストケースを含む、あまり公式でない仕様を好む傾向があります。

**トピック:**

[必修]
* 例えば、ユースケースやユーザーストーリーを使用した機能要件の記述
* 要件の特性、つまり一貫性、妥当性、完全性、実現可能性

[選択必修]
* ソフトウェアの要求抽出
* 例えば、クラス図や実体関連図 (ER図) を使用したシステムデータの記述
* 非機能要件とソフトウェア品質との関係（相互参照: [IAS/安全なソフトウェア工学](./z_appendix_A_IAS.md#ias安全なソフトウェア工学))
* 要求仕様の評価と使用

[選択科目]
* 要求分析モデリング技術
* ソフトウェア/システムの動作に関する確実性/不確実性の受け入れ可能性
* プロトタイピング
* 形式的な要求仕様の基本概念
* 要求仕様
* 要求の検証
* 要求追跡

**学習到達目標:**

[必修]
1. システムに要求される振る舞いの説明やユースケースから、主要な構成要素をリストアップする。[知識]
2. 要求工学のプロセスが、システムに要求される振る舞いの抽出と検証をどのようにサポートするか説明する。[知識]
3. 単純なソフトウェアシステムに関する与えられた要求モデルを解釈する。[知識]

[選択必修]
4. 要件抽出の基本的な課題と一般的に使用される技術を説明する。[知識]
5. データモデル（例：クラス図やER図）の主要な要素をリストアップする。[知識]
6. 与えられたソフトウェアシステムの要求仕様において、機能要件と非機能要件の両方を特定する。[使用]
7. 良い要求が備える特徴を鑑み、ソフトウェアの要求セットのレビューを実施して要求の品質を決定する。[使用]

[選択科目]

8. 中規模のソフトウェアシステムの要求仕様を作成するために、要求抽出と分析のための主要な要素と一般的な方法を適用する。[使用]
9. 計画駆動型とアジャイル型について、要求仕様や検証のアプローチを比較し、それぞれの利点と関連するリスクを説明する。[知識]
10. 一般的な非形式的な方法を使用して、中規模のソフトウェアシステムの要求をモデル化し、仕様を定義する。[使用]
11. 使用記述言語で書かれたソフトウェア要求仕様（例えば、ソフトウェアコンポーネント契約）を自然言語に翻訳する。[使用]
12. 要求におけるリスクを軽減するために、ソフトウェアシステムのプロトタイプを作成する。[使用]
13. 前方追跡と後方追跡の違いを明確にし、要求検証プロセスにおけるそれらの役割を説明する。[知識]



## SE/ソフトウェア設計
*[必修 3時間, 選択必修 5時間]*

**トピック:**

[必修]
* システムデザインの原則: 抽象化のレベル (アーキテクチャ設計と詳細設計)、関心の分離、情報隠蔽、結合度と凝集度、標準構造の再利用
* デザインパラダイム、たとえば構造化デザイン (トップダウンの機能分解)、オブジェクト指向分析と設計、イベント駆動設計、コンポーネントレベル設計、データ中心設計、アスペクト指向、関数指向、サービス指向
* ソフトウェアデザインの構造および動作モデル
* デザインパターン

[選択必修]

* 要求と設計の関係: モデル変換・契約設計・不変性
* ソフトウェアアーキテクチャの概念と標準アーキテクチャ (例えば、クライアントサーバー、n層、変換中心、パイプとフィルタ)
* デザインパターンを使用した設計のリファクタリング
* 設計におけるコンポーネントの用途: コンポーネントの選択、適用、設計や、複数のコンポーネントやパターン、オブジェクトを用いた構築（例えば、標準ウィジェット群を使用したGUIの構築）

[選択科目]

* 内部設計品質とそれらのモデル: 効率性と性能、冗長性と耐障害性、要求の追跡可能性
* 外部設計品質とそれらのモデル: 機能性、信頼性、性能と効率性、使いやすさ、保守性、移植性
* 設計品質の測定と分析
* 品質の異なる側面間のトレードオフ
* アプリケーションフレームワーク
* ミドルウェア: ミドルウェア内のオブジェクト指向パラダイム、オブジェクトリクエストブローカとマーシャリング、トランザクション処理モニター、ワークフローシステム
* 安全な設計とコーディングの原則 (相互参照: [IAS/設計の原則](./z_appendix_A_IAS.md#ias設計の原則))
 * 最小特権の原則
 * フェイルセーフデフォルトの原則
 * 心理的受容性の原則

**学習到達目標:**

[必修]
1. 関心の分離、情報の隠蔽、結合度と凝集度、カプセル化などの設計原則を明確に述べる。[知識]
2. 設計パラダイムを使用して簡単なソフトウェアシステムを設計し、この設計においてシステム設計原則がどのように適用されたか説明する。[使用]
3. パラダイム沿って設計された簡単なソフトウェアシステムの設計モデルを作成する。[使用]
4. 単一の設計パラダイムの文脈内で、単純なソフトウェアシステムの設計に適用可能な1つ以上のデザインパターンを説明する。[知識]

[選択必修]
5. 与えられたシナリオに沿った簡単なシステムのために、適切な設計パラダイムを議論し、選択する。[使用]
6. 要求仕様からソフトウェア製品の構造と振る舞いの適切なモデルを作成する。[使用]
7. 適切なモデルを使用して、ソフトウェア製品の要求とその設計との関係を説明する。[評価]
8. 単一の設計パラダイムの文脈内で設計された簡単なソフトウェアシステムについて、そのシステムのソフトウェアアーキテクチャを説明する。[知識]
9. 高レベルの設計が与えられた場合、一般的なソフトウェアアーキテクチャ (3層、パイプ・アンド・フィルタ、クライアント・サーバなど) の違いを考慮して、ソフトウェアアーキテクチャを割り出す。[知識]
10. ソフトウェアアーキテクチャの選択が簡単なシステムの設計にどのような影響を及ぼすか調査する。[評価]
11. パターンの簡単な実用例をソフトウェア設計に適用する。[使用]
12. リファクタリングの類型を説明し、それが適用可能な場合を議論する。[知識]
13. ソフトウェア製品の設計に使用する適切なコンポーネントを選択する。[使用]
14. 適切なコンポーネントをソフトウェア製品の設計に使用するために、どのように改修する必要があるかを説明する。[知識]
15. システムで使用されている典型的な小規模ソフトウェアコンポーネントに対して、契約を設計する。[使用]


[選択科目]
16. 与えられたシナリオに沿った簡単なシステムのために、適切なソフトウェアアーキテクチャについて議論し、選択する。[使用]
17. ソフトウェアコンポーネントの設計における内部・外部品質のモデルを適用し、品質の相反する側面間で許容可能なトレードオフを達成する。[使用]
18. 重要な内部品質特性の視点からソフトウェア設計を分析する。[評価]
19. 重要な外部品質特性の視点からソフトウェア設計を分析する。[評価]
20. ミドルウェアシステムにおけるオブジェクトの役割と、コンポーネントとの関係を説明する。[知識]
21. コンポーネントを使用した並行処理やトランザクション、高信頼通信サービス、リモートクエリやデータベース管理などデータベースとの相互作用、または安全な通信とアクセスなど、さまざまなソフトウェアの設計にコンポーネント指向のアプローチを適用する。[使用]
22. 設計のある側面を改善するために、既存のソフトウェア実装をリファクタリングする。[使用]
23. 最小特権の原則とフェールセーフデフォルトの原則を明示し、適用する。[知識]




## SE/ソフトウェアの構築
*[選択必修 2時間]*

**トピック:**

[選択必修]
* コーディングの実践: 高品質なプログラムを作るための技術、イディオム/パターン、メカニズム ( 相互参考: [IAS/防御プログラミング](./z_appendix_A_IAS.md#ias防御プログラミング); [SDF/開発方法](./z_appendix_A_SDF.md#sdf開発方法))
 * 防御的コーディングの実践
 * 安全なコーディングの実践
 * プログラムをより頑健で耐障害性のあるものにするための例外処理メカニズムの使用
* コーディング標準
* 統合戦略
* 開発文脈: 新規 vs 既存のコードベース
 * 変更の影響分析
 * 変更の実現化

[選択科目]
* プログラムにおける潜在的なセキュリティ問題
 * バッファオーバーフローやその他の種類のオーバーフロー
 * 競合状態
 * 権限の選択を含む不適切な初期化
 * 入力のチェック
 * 仮定された成功と正確さ
 * 仮定の検証

**学習到達目標:**

[選択必修]
1. 信頼性、効率性、堅牢性など、求められる特性を実装するための技術、コーディングイディオム、メカニズムを説明する。[知識]
2. 例外処理メカニズムを使用して堅牢なコードを構築する。[使用]
3. セキュアコーディングと防御的コーディングの実践を説明する。[知識]
4. 小規模なソフトウェアプロジェクトにおいて、確立されたコーディング標準を選択し使用する。[使用]
5. トップダウン、ボトムアップ、サンドイッチインテグレーションを含む統合戦略を比較対比する。[知識]
6. 特定のプロジェクトで開発されたコードベースへの変更の分析と実装のプロセスを説明する。[知識]
7. 大規模な既存のコードベースへの変更の分析と実装のプロセスを説明する。[知識]

[選択科目]
8. バッファオーバーフロー、整数オーバーフロー、競合状態などの一般的な脆弱性を除去するために、単純なプログラムを書き直す。[使用]
9. 入力エラーやランタイムエラーに対して回復力のある、何か非自明なタスクを実行するソフトウェアコンポーネントを書く。[使用]



## SE/ソフトウェアの検証と妥当性確認
*[選択必修 4時間]*

**トピック:**

[選択必修]
* 検証と確認の概念
* 検査、レビュー、監査
* 人間とコンピュータのインターフェース、使いやすさ、信頼性、セキュリティ、仕様への適合性などのテスト種別 (相互参照: [IAS/安全なソフトウェア工学](./z_appendix_A_IAS.md#ias安全なソフトウェア工学))
* テストの基礎 (相互参照: [SDF/開発方法](./z_appendix_A_SDF.md#sdf開発方法)）
 * 単体試験、結合試験、妥当性確認試験、システムテスト
 * テスト計画作成とテストケース生成
 * ブラックボックステストとホワイトボックステスト技術
 * 回帰テストとテスト自動化
* 欠陥追跡
* 並行システムやセーフティクリティカルシステムなど、特定のドメインでのテストの限界

[選択科目]
* 検証の静的アプローチと動的アプローチ
* テスト駆動開発
* 検証計画; 検証のための文書化
* オブジェクト指向テスト; システムテスト
* コード以外の成果物（ドキュメンテーション、ヘルプファイル、トレーニングマテリアル）の検証と確認
* 欠陥の記録と追跡、そのような活動のための技術サポート
* 欠陥数の見積もりとテストの終了。エラー埋込法を含む。

**学習到達目標:**

[選択必修]
1. プログラムの妥当性確認と検証の違いを説明する。[知識]
2. ツールがソフトウェアの妥当性確認にどのような役割を果たすことができるか説明する。[知識]
3. チーム活動の一部として、中規模のコードセグメントの検査を行う。[使用]
4. テストの異なる種類とレベル (単体試験、結合試験、システムテスト、受け入れ試験) を説明し、区別する。[知識]
5. 結合試験、回帰テスト、システムテストに対する重要なテストケースを特定する技術を説明する。[知識]
6. 中規模のコードセグメントに対する一連のテストを作成し、文書化する。[使用]
7. 優れた回帰テストを選択し、自動化する方法を説明する。[知識]
8. 小規模のソフトウェアプロジェクトでソフトウェアの欠陥を管理するために欠陥追跡ツールを使用する。[使用]
9. 特定の領域でのテストの限界について議論する。[知識]

[選択科目]
10. 中規模のコードセグメントに対するテストスイートを評価する。[使用]
11. 妥当性確認に対する静的なアプローチと動的なアプローチを比較する。[知識]
12. テスト駆動開発方法の基本的な原則を特定し、これらの方法における自動テストの役割を説明する。[知識]
13. オブジェクト指向ソフトウェアのテストに関わる問題を議論する。[使用]
14. 非コード成果物の検証と妥当性確認のための技術を説明する。[知識]
15. 欠陥数の見積りのためのアプローチを説明する。[知識]
16. 欠陥密度とエラー埋込法に基づいて小規模なソフトウェアアプリケーションの欠陥数を推定する。[使用]
17. 小規模または中規模のソフトウェアプロジェクトのソフトウェアソースコードの検査またはレビューを行う。[使用]



## SE/ソフトウェア進化・発展
*[選択必修 2時間]*

**トピック:**

* 既存の大規模なコードベースにおいてのソフトウェア開発
 * ソフトウェアの変更
 * 複数の関心と、関心の実装位置特定
 * リファクタリング
* ソフトウェアの進化・発展
* 保守可能なソフトウェアの特性
* システムの再構築
* ソフトウェアの再利用
 * コードセグメント
 * ライブラリとフレームワーク
 * コンポーネント
 * 製品種目

**学習到達目標:**

1. ソフトウェアの進化に関する主要な問題を特定し、ソフトウェアライフサイクルに与える影響を説明する。[知識]
2. 中規模の既存の製品への変更要求の影響を推定する。[使用]
3. ソフトウェアコンポーネントの修正プロセスにリファクタリングを使用する。[使用]
4. 変化する環境でのシステムの進化の課題を議論する。[知識]
5. 回帰テストのプロセスとリリース管理におけるその役割を概説する。[知識]
6. ソフトウェアの再利用のさまざまな種別の利点と欠点を議論する。[知識]



## SE/ソフトウェアの信頼性
*[必修 1時間]*

**トピック:**

[選択必修]
* ソフトウェア信頼性工学の概念
* ソフトウェアの信頼性、システムの信頼性、および障害の挙動 (相互参照: [SF/冗長化による信頼性向上](./z_appendix_A_SF.md#sf冗長化による信頼性向上))
* 障害ライフサイクルの概念と手法

[選択科目]
* ソフトウェア信頼性モデル
* ソフトウェア耐障害性の手法とモデル
* ソフトウェア信頼性工学の実践
* ソフトウェア信頼性の測定に基づく分析

**学習到達目標:**

[選択必修]
1. 非常に高い信頼性を達成する上で存在する問題を説明する。[知識]
2. ソフトウェアの信頼性がシステムの信頼性にどのように貢献するかを説明する。[知識]
3. ソフトウェアライフサイクルの各段階で適用可能な、障害を最小限に抑えるアプローチをリストアップする。[知識]

[選択科目]
4. 三つの異なる信頼性モデリングアプローチの特性を比較する。[知識]
5. ソフトウェアシステムの信頼性推定を行うための複数の方法を適用できる。[使用]
6. 指定されたレベルの信頼性を達成するために、ソフトウェアアーキテクチャに実現可能な方法を特定する。[使用]
7. 中規模のアプリケーションで冗長性を適用し、耐障害性を得る方法を特定する。[使用]



## SE/形式手法
*[選択科目]*

以下に示すトピックは、特に[DS/集合・関係・函数](./z_appendix_A_DS.md#ds集合関係函数)、[DS/論理の基礎](./z_appendix_A_DS.md#ds論理の基礎)、[DS/論証の技法](./z_appendix_A_DS.md#ds論証の技法) といった知識単位を含む、[離散構造(DS)](./z_appendix_A_DS.md)知識領域のコア題材に強い依存性を持っています。

**トピック:**

* ソフトウェア開発サイクルにおける形式的な仕様と分析手法の役割
* プログラムのアサーション言語と分析アプローチ（OCL、JMLなどの事前・事後条件を記述・分析する言語を含む）
* ソフトウェアのモデリングと分析に対する形式的なアプローチ
 * モデルチェッカー
 * モデルファインダー
* 形式手法を支援するツール


**学習到達目標:**

1. 複雑なソフトウェアの開発において、形式的な仕様と分析技術が果たす役割を説明し、それらを検証と妥当性確認の技術としてテストと比較する。[知識]
2. 低複雑度のソフトウェア設計とプログラムに形式的な仕様と分析技術を適用する。[使用]
3. 仕様記述言語の使用による潜在的な利点と欠点を説明する。[知識]
4. 単純なものから複雑なものまで、さまざまな振る舞いに対するプログラムのアサーションを作成し、評価する。[使用]
5. 一般的な仕様記述言語を使用して、単純なソフトウェアシステムの仕様を整理し、その仕様からテストケースの例を導き出す。[使用]
