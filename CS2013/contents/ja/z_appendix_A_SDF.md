
# ソフトウェア開発基礎 (SDF)

Fluency in the process of software development is a prerequisite to the study of most of
computer science. In order to use computers to solve problems effectively, students must be
competent at reading and writing programs in multiple programming languages. Beyond
programming skills, however, they must be able to design and analyze algorithms, select
appropriate paradigms, and utilize modern development and testing tools. This knowledge area
brings together those fundamental concepts and skills related to the software development
process. As such, it provides a foundation for other software-oriented knowledge areas, most
notably Programming Languages, Algorithms and Complexity, and Software Engineering.

It is important to note that this knowledge area is distinct from the old Programming
Fundamentals knowledge area from CC2001. Whereas that knowledge area focused exclusively
on the programming skills required in an introductory computer science course, this new
knowledge area is intended to fill a much broader purpose. It focuses on the entire software
development process, identifying those concepts and skills that should be mastered in the first
year of a computer science program. This includes the design and simple analysis of algorithms,
fundamental programming concepts and data structures, and basic software development
methods and tools. As a result of its broader purpose, the Software Development Fundamentals
knowledge area includes fundamental concepts and skills that could naturally be listed in other
software-oriented knowledge areas (e.g., programming constructs from Programming
Languages, simple algorithm analysis from Algorithms & Complexity, simple development
methodologies from Software Engineering). Likewise, each of these knowledge areas will
contain more advanced material that builds upon the fundamental concepts and skills listed here.

While broader in scope than the old Programming Fundamentals, this knowledge area still allows
for considerable flexibility in the design of first-year curricula. For example, the Fundamental
Programming Concepts unit identifies only those concepts that are common to all programming
paradigms. It is expected that an instructor would select one or more programming paradigms
(e.g., object-oriented programming, functional programming, scripting) to illustrate these
programming concepts, and would pull paradigm-specific content from the Programming
Languages knowledge area to fill out a course. Likewise, an instructor could choose to
emphasize formal analysis (e.g., Big-Oh, computability) or design methodologies (e.g., team
projects, software life cycle) early, thus integrating hours from the Programming Languages,
Algorithms and Complexity, and/or Software Engineering knowledge areas. Thus, the 43 hours
of material in this knowledge area will typically be augmented with core material from one or
more of these knowledge areas to form a complete and coherent first-year experience.

When considering the hours allocated to each knowledge unit, it should be noted that these hours
reflect the minimal amount of classroom coverage needed to introduce the material. Many
software development topics will reappear and be reinforced by later topics (e.g., applying
iteration constructs when processing lists). In addition, the mastery of concepts and skills from
this knowledge area requires a significant amount of software development experience outside of
class.


**SDF. ソフトウェア開発基礎 (必修 43時間)**

| 知識単位 | 必修時間 | 選択必修時間 | 含選択科目 |
| -------- | -------- | ------------ | ---------- |
| SDF/アルゴリズムと設計       | 11 |   | N |
| SDF/プログラミングの基本概念 | 10 |   | N |
| SDF/基本データ構造           | 12 |   | N |
| SDF/開発方法                 | 10 |   | N |



## SDF/アルゴリズムと設計
*[必修 11時間]*

This unit builds the foundation for core concepts in the Algorithms and Complexity Knowledge
Area, most notably in the Basic Analysis and Algorithmic Strategies knowledge units.

**トピック:**

* The concept and properties of algorithms
 * Informal comparison of algorithm efficiency (e.g., operation counts)
* The role of algorithms in the problem-solving process
* Problem-solving strategies
 * Iterative and recursive mathematical functions
 * Iterative and recursive traversal of data structures
 * Divide-and-conquer strategies
* Fundamental design concepts and principles
 * Abstraction
 * Program decomposition
 * Encapsulation and information hiding
 * Separation of behavior and implementation


**学習到達目標:**

1. Discuss the importance of algorithms in the problem-solving process. [Familiarity]
2. Discuss how a problem may be solved by multiple algorithms, each with different properties. [Familiarity]
3. Create algorithms for solving simple problems. [Usage]
4. Use a programming language to implement, test, and debug algorithms for solving simple problems.
[Usage]
5. Implement, test, and debug simple recursive functions and procedures. [Usage]
6. Determine whether a recursive or iterative solution is most appropriate for a problem. [Assessment]
7. Implement a divide-and-conquer algorithm for solving a problem. [Usage]
8. Apply the techniques of decomposition to break a program into smaller pieces. [Usage]
9. Identify the data components and behaviors of multiple abstract data types. [Usage]
10. Implement a coherent abstract data type, with loose coupling between components and behaviors. [Usage]
11. Identify the relative strengths and weaknesses among multiple designs or implementations for a problem.
[Assessment]



## SDF/プログラミングの基本概念
*[必修 10時間]*

This knowledge unit builds the foundation for core concepts in the Programming Languages
Knowledge Area, most notably in the paradigm-specific units: Object-Oriented Programming,
Functional Programming, and Event-Driven & Reactive Programming.

**トピック:**

* Basic syntax and semantics of a higher-level language
* Variables and primitive data types (e.g., numbers, characters, Booleans)
* Expressions and assignments
* Simple I/O including file I/O
* Conditional and iterative control structures
* Functions and parameter passing
* The concept of recursion

**学習到達目標:**

1. Analyze and explain the behavior of simple programs involving the fundamental programming
constructs variables, expressions, assignments, I/O, control constructs, functions, parameter passing,
and recursion. [Assessment]
2. Identify and describe uses of primitive data types. [Familiarity]
3. Write programs that use primitive data types. [Usage]
4. Modify and expand short programs that use standard conditional and iterative control structures and
functions. [Usage]
5. Design, implement, test, and debug a program that uses each of the following fundamental
programming constructs: basic computation, simple I/O, standard conditional and iterative structures,
the definition of functions, and parameter passing. [Usage]
6. Write a program that uses file I/O to provide persistence across multiple executions. [Usage]
7. Choose appropriate conditional and iteration constructs for a given programming task. [Assessment]
8. Describe the concept of recursion and give examples of its use. [Familiarity]
9. Identify the base case and the general case of a recursively-defined problem. [Assessment]



## SDF/基本データ構造
*[必修 12時間]*

This unit builds the foundation for core concepts in the Algorithms and Complexity Knowledge
Area, most notably in the Fundamental Data Structures and Algorithms and Basic Computability
and Complexity knowledge units.

**トピック:**

* Arrays
* Records/structs (heterogeneous aggregates)
* Strings and string processing
* Abstract data types and their implementation
 * Stacks
 * Queues
 * Priority queues
 * Sets
 * Maps
* References and aliasing
* Linked lists
* Strategies for choosing the appropriate data structure

**学習到達目標:**

1. Discuss the appropriate use of built-in data structures. [Familiarity]
2. Describe common applications for each of the following data structures: stack, queue, priority queue, set,
and map. [Familiarity]
3. Write programs that use each of the following data structures: arrays, records/structs, strings, linked lists,
stacks, queues, sets, and maps. [Usage]
4. Compare alternative implementations of data structures with respect to performance. [Assessment]
5. Describe how references allow for objects to be accessed in multiple ways. [Familiarity]
6. Compare and contrast the costs and benefits of dynamic and static data structure implementations.
[Assessment]
7. Choose the appropriate data structure for modeling a given problem. [Assessment]



## SDF/開発方法
*[必修 10時間]*

This unit builds the foundation for core concepts in the Software Engineering knowledge area,
most notably in the Software Processes, Software Design and Software Evolution knowledge
units.

**トピック:**

* Program comprehension
* Program correctness
 * Types of errors (syntax, logic, run-time)
 * The concept of a specification
 * Defensive programming (e.g. secure coding, exception handling)
 * Code reviews
 * Testing fundamentals and test-case generation
 * The role and the use of contracts, including pre- and post-conditions
 * Unit testing
* Simple refactoring
* Modern programming environments
 * Code search
 * Programming using library components and their APIs
* Debugging strategies
* Documentation and program style

**学習到達目標:**

1. Trace the execution of a variety of code segments and write summaries of their computations. [Assessment]
2. Explain why the creation of correct program components is important in the production of high-quality
software. [Familiarity]
3. Identify common coding errors that lead to insecure programs (e.g., buffer overflows, memory leaks,
malicious code) and apply strategies for avoiding such errors. [Usage]
4. Conduct a personal code review (focused on common coding errors) on a program component using a
provided checklist. [Usage]
5. Contribute to a small-team code review focused on component correctness. [Usage]
6. Describe how a contract can be used to specify the behavior of a program component. [Familiarity]
7. Refactor a program by identifying opportunities to apply procedural abstraction. [Usage]
8. Apply a variety of strategies to the testing and debugging of simple programs. [Usage]
9. Construct, execute and debug programs using a modern IDE and associated tools such as unit testing tools
and visual debuggers. [Usage]
10. Construct and debug programs using the standard libraries available with a chosen programming language.
[Usage]
11. Analyze the extent to which another programmer’s code meets documentation and programming style
standards. [Assessment]
12. Apply consistent documentation and program style standards that contribute to the readability and
maintainability of software. [Usage]
