
# 並列分散処理 (PD)

過去10年間で、マルチプロセッサコンピューティング、つまり、マルチコアプロセッサや分散データセンターの爆発的な成長が見られました。その結果、並列分散処理は、従来は幅広く選択科目とされていましたが、現在は学部のコンピューティングカリキュラムのコアな部分となりました。並列処理・分散処理の両方とも、複数のプロセスが論理的に同時に実行され、その操作が複雑な方法で交錯する可能性があります。並列分散処理は、並行性や並列実行、状態/メモリ操作の一貫性、遅延といった基礎的なシステム概念の理解を含む多くの領域の基礎に基づいています。プロセス間の通信と協調は、メッセージパッシングと共有メモリといった計算モデル、そして原子性、合意、条件付き待機といったアルゴリズム概念に根ざしています。実際に速度向上を達成するためには、並列アルゴリズム、問題分解の戦略、システムアーキテクチャ、詳細な実装戦略、性能分析とチューニングの理解が必要です。分散システムは、セキュリティと耐障害性の問題を強調し、複製状態の維持を重視し、コンピュータネットワークへと繋がる追加の課題を導入します。


並列性は、少なくともアルゴリズム、言語、システム、ネットワーク、ハードウェアを含むコンピューティングの多くの領域と相互作用しますので、多くのカリキュラムでは、専用の講座ではなく、様々な講座でこの知識領域の様々な部分を教えることになります。我々は、コンピュータ科学が並列分散処理の専門講座を持つ方向に進んでおり、すでにそうなっているかもしれないと認識していますが、2013年現在、このプロセスはまだ変動しています。我々は、基本的な並列性のトピックを一か所にまとめることで、カリキュラム設計者により有用な指針を提供できると考えています。ただし、並列性と相互排他の基本的な内容は、[システム基礎 (SF)](./z_appendix_A_SF.md)知識領域に含まれていることに注意してください。多くのカリキュラムは、並行性と並列性を同じ講座で導入するでしょう (これらの用語の区別については下記を参照してください）。さらに、下記に一覧化されているトピックと学習到達目標には、純粋に選択科目の範囲についての簡単な言及のみが含まれています。現時点では、共通点が少ないトピック (例えば、並列科学計算、プロセス計算、ノンブロッキングデータ構造など)の多様性がありすぎて、特定のトピックを選択科目でカバーすべきと推奨することはできません。

並列分散処理の用語はコミュニティによって異なるため、ここではいくつかの用語の意図された意味について簡単な説明を提供します。このリストは包括的でも決定的なものでもなく、明確さのために提供されています。

* 並列性(Parallelism): 通常は速度向上のために、追加の計算リソースを同時に使用すること。
* 並行性(Concurrency): リソースへの並行アクセスを効率的かつ正しく管理すること。
* アクティビティ(Activity): 他と並行して進行可能な計算。例えば、プログラム、プロセス、スレッド、またはアクティブな並列ハードウェアコンポーネント。
* 原子性(Atomicity): 動作が観察上不可分であるかに影響する規則と特性; 例えば、ワード内の全ビットの設定、単一パケットの送信、またはトランザクションの完了。
* 合意(Consensus): 特定の述語についての2つ以上のアクティビティ間の合意; 例えば、カウンターの値、ロックの所有者、またはスレッドの終了。
* 一貫性(Consistency): 一部のアクティビティによって書き込まれた変数の値や生成されたメッセージについて、他のアクティビティが使用する（つまり潜在的なデータ競合がある）際の合意に影響する規則と特性; 例えば逐次一貫性とは、共有メモリ並列プログラム内の全ての変数の値が、メモリアクセスを各アクティビティ内での順序を崩さない形で一つにまぜこんだ単一プログラムにおける変数の値と等価になることを意味しています。
* マルチキャスト(Multicast): 多数の受信者に送信可能なメッセージで、一部の受信者が他の受信者よりも先にメッセージを受信するかどうかについての制約は一般的にありません。イベントは指定されたリスナーや購読者のセットに送信されるマルチキャストメッセージです。

マルチプロセッサでの計算が今後数年でさらに利用されるにつれ、並列分散処理が計算機科学の学部カリキュラムで果たす役割も増すことでしょう。ここで提示したガイドラインに加えて、興味のある読者は、"NSF/TCPP Curriculum Initiative on Parallel and Distributed Computing - Core Topics for Undergraduates"も参照ください。この文書は以下のウェブサイトから入手できます: https://tcpp.cs.gsu.edu/curriculum/

**全般的な相互参照についての注意:** [システム基礎](./z_appendix_A_SF.md)には、並列化への導入([SF/計算パラダイム](./z_appendix_A_SF.md#sf計算パラダイム)、[SF/並列処理](./z_appendix_A_SF.md#sf並列処理)、[SF/性能評価](./z_appendix_A_SF.md#sf性能評価)）も含まれています。

[SF](./z_appendix_A_SF.md)における並列化の導入は、ここでのものと補完的であり、間に順序の制約はありません。SFでは、複数の抽象化レベルにおけるシステムの同時実行の支援について、統一的な視点を提供することが目的です（並列化はゲート、プロセッサ、オペレーティングシステム、サーバーにつきものです）。一方、ここでは、並列化を計算の基本要素として初歩的に理解し、並列および並行プログラミングで生じる複雑さに焦点を当てています。これらの異なる視点を考慮に入れると、各々に割り当てられた時間は重複していません: システムを層状とみる視点と、計算の高レベルな概念は、コア時間の観点から別々に考慮されます。


**PD. 並列分散処理 (必修 5時間, 選択必修 10時間)**

| 知識単位 | 必修時間 | 選択必修時間 | 含選択科目 |
| -------- | -------- | ------------ | ---------- |
| PD/並列性の基礎                           | 2 |   | N |
| PD/並列処理への分割                       | 1 | 3 | N |
| PD/通信と協調                             | 1 | 3 | Y |
| PD/並列アルゴリズム・解析とプログラミング |   | 3 | Y |
| PD/並列アーキテクチャ                     | 1 | 1 | Y |
| PD/並列性能                               |   |   | Y |
| PD/分散システム                           |   |   | Y |
| PD/クラウドコンピューティング             |   |   | Y |
| PD/形式モデルと意味論                     |   |   | Y |



## PD/並列性の基礎
*[必修 2時間]*

システム基礎で取り上げられる基本的な並列実行の概念に対する学生の理解を深め、その概念から生じる複雑な問題、例えば競合状態 (race condition) や生存性 (liveness)について掘り下げます。

相互参照: [SF/計算パラダイム](./z_appendix_A_SF.md#sf計算パラダイム)、[SF/並列処理](./z_appendix_A_SF.md#sf並列処理)


**トピック:**

* 複数の同時計算
* 並列性（例えば、スループット）と並行性（例えば、共有リソースへのアクセス制御）の目標
* 並列性、通信、協調
 * 複数の同時計算を協調させるためのプログラミング構造
 * 同期の必要性
* 逐次プログラミングにはないプログラミングエラー
 * データ競合 (共有状態の同時読み書き、同時書き込み)
 * ハイレベルの競合 (プログラムの意図しないインターリーブ、望ましくない非決定性)
 * 生存性/進行性の欠如 (デッドロック、スターベーション)

**学習到達目標:**

1. 高速性の為の計算リソースの使用と、共有リソースへの効率的なアクセス管理を区別する。 [知識]
2. 十分な数の同期のためのプログラミング構造を区別する。これらは相互に実装可能だが、補完的な利点がある。 [知識]
3. データ競合とハイレベルの競合を区別する。 [知識]



## PD/並列処理への分割
*[必修 1時間, 選択必修 3時間]*

(相互参照: [SF/並列処理](./z_appendix_A_SF.md#sf並列処理))

**トピック:**

[必修]

* 通信と強調/同期の必要性
* 独立性と分割


[選択必修]

* 並列分解の概念についての基礎知識 (相互参照: [SF/並列処理](./z_appendix_A_SF.md#sf並列処理))
* タスクベースの分解
 * スレッドなどの実装戦略
* データ並列分解
 * SIMDやMapReduceなどの戦略
* アクターと応答型プロセス（例えば、リクエストハンドラー）

**学習到達目標:**

[必修]

1. 特定の並列プログラムについて、同期が必要な理由を説明する。 [使用]
2. 逐次プログラムをどのように分割して独立した並列モジュールにできるか割り出す。 [知識]

[選択必修]

3. 正確でスケーラブルな並列アルゴリズムを記述する。 [使用]
4. タスクベースの分解を適用してアルゴリズムを並列化する。 [使用]
5. データ並列分解を適用してアルゴリズムを並列化する。 [使用]
6. アクターや応答型プロセスを使用したプログラムを記述する。 [使用]


## PD/通信と協調
*[必修 1時間, 選択必修 3時間]*

実装上の課題について [OS/並行性](./z_appendix_A_OS.md#os並行性)と相互参照。

**トピック:**

[必修]

* 共有メモリ
* 一貫性。データ競合のないプログラムに対し一貫性がプログラミング言語で果たす役割

[選択必修]

* メッセージパッシング
 * ポイントツーポイント vs マルチキャスト (またはイベントベース) メッセージ
 * メッセージの送受信の様式。ブロッキング vs ノンブロッキング。
 * メッセージバッファリング (相互参照: [SDF/基本データ構造](./z_appendix_A_SDF.md#sdf基本データ構造)のキュー)
* 原子性
 * 原子性や安全性要件の指定とテスト
 * 不可分操作の粒度、およびそれらを記述するためのクリティカルセクションやトランザクションなどの構造の使用
 * ロック、セマフォ、モニタ、または関連する構造を使用した相互排他
  * 生存性の欠落とデッドロック (原因、条件、予防)
 * 合成
  * 同期を使用して大粒度の不可分操作を構成する
  * トランザクション。楽観的および保守的なアプローチを含む。

[選択科目]

* 合意
 * (循環式) バリア、カウンタ、または関連する構造
* 条件付きアクション
 * 条件付き待機（例えば、条件変数を使用）


**学習到達目標:**

[必修]
1. 与えられた競合状態に対して、相互排他を利用して解決する。[使用]
2. 複数の並行アクティビティの資源アクセス順で、逐次一貫性の無い例を挙げる（例えば、データ競合のあるプログラム）[理解]

[選択必修]
3. メッセージのブロッキング送信がデッドロックを引き起こすシナリオの例を挙げる。[使用]
4. マルチキャストやイベントベースのメッセージングが他の選択肢よりも好ましい場面と理由を説明する。[理解]
5. 一連の並行タスクがすべて完了したときに正しく終了するプログラムを書く。[使用]
6. 適切に同期化されたキューを使用して、アクティビティ間でデータをバッファリングする。[使用]
7. 前提条件のチェックと、それに基づくアクションが実効的であるためには、同じ原子性の単位に属する必要がある理由を説明する。[理解]
8. 並行プログラミングエラーを披露するテストプログラムを書く。例えば、2つのアクティビティが変数をインクリメントしようとしたときに更新が失われる。[使用]
9. 複数のロックやセマフォを使用するプログラムで生存性を担保するための設計手法を少なくとも1つ説明する。[理解]
10. 楽観的/保守的な並行性制御の相対的な利点について、更新頻度の度合いが異なる場面で説明する。[理解]
11. 楽観的な更新の試みが完了しないシナリオの例を挙げる。[理解]

[選択科目]
12. セマフォや条件変数を使用して、必要な前提条件が満たされるまでスレッドをブロックする。[使用]



## PD/並列アルゴリズム・解析とプログラミング
*[選択必修 3時間]*

**トピック:**

[選択必修]

* クリティカルパス、ワーク (work, 逐次実行時時間) と スパン (span, 限界並列時時間)、およびアムダールの法則との関係 (相互参照: [SF/性能評価](./z_appendix_A_SF.md#sf性能評価))
* 速度向上とスケーラビリティ
* 自明に並列化されたアルゴリズム
* 並列アルゴリズムのパターン (分割統治、マップリデュース、マスター/ワーカー、他)
 * 具体的アルゴリズム (例えば、並列マージソート)

[選択科目]

* 並列グラフアルゴリズム (例えば、並列最短経路、並列最小全域木) (相互参照: [AL/アルゴリズム設計の手法](./z_appendix_A_AL.md#alアルゴリズム設計の手法)の分割統治）
* 並列行列計算
* プロデューサー・コンシューマとパイプライン化されたアルゴリズム
* スケーラブルでない並列アルゴリズムの例


**学習到達目標:**

[選択必修]

1. 「クリティカルパス」、「ワーク」、「スパン」を定義する。[知識]
2. ワークとスパンを計算し、並行実行依存関係図に対するクリティカルパスを特定する。[使用]
3.「速度向上」を定義し、この観点からのアルゴリズムのスケーラビリティについて説明する。[知識]
4. 並列化可能なプログラム内の独立したタスクを特定する。[使用]
5. ワークロードの特徴で、自然に並列化を可能するもの・不可能にするものを特定し、理由を説明する。[知識]
6. 並列分割統治や並列グラフアルゴリズムを実装し、その性能を実際に測定し、逐次版と比較する。[使用]
7. 問題 (例えば、ドキュメント内の特定の単語の出現数を数えるなど) をマップおよびリデュース操作に分解する。[使用]

[選択科目]
8. プロデューサーコンシューマーパラダイムに適合する問題の例を挙げる。[知識]
9. パイプライン化が並列化の効果的な手段となる問題の例を挙げる。[知識]
10. 並列行列アルゴリズムを実装する。[使用]
11. プロデューサーコンシューマーアルゴリズム特有の問題点を特定し、それらに対処するための仕組みを認識する。[知識]



## PD/並列アーキテクチャ
*[必修 1時間, 選択必修 1時間]*

ここに記載されるトピックは、[アーキテクチャと構成 (AR)](./z_appendix_A_AR.md) の知識領域（[AR/アセンブリ言語レベルでのコンピュータの構成](./z_appendix_A_AR.md#arアセンブリ言語レベルでのコンピュータの構成)と[AR/マルチプロセッシングとその構成の選択肢](./z_appendix_A_AR.md#arマルチプロセッシングとその構成の選択肢)) の知識単位に関連しています。ここでは、アプリケーションの観点から並列アーキテクチャに焦点を当てていますが、アーキテクチャと構成の知識領域は、このトピックをハードウェアの観点から提示します。


**トピック:**

[必修]
* マルチコアプロセッサ
* 共有メモリ vs 分散メモリ

[選択必修]
* 対称型マルチプロセッシング（SMP）
* SIMD、ベクトル計算機

[選択科目]
* GPU、コプロセッサ
* フリンの分類
* 並列プログラミングのための命令レベルの支援
 * Compare and Setのような不可分操作
* メモリ問題
 * マルチプロセッサキャッシュとキャッシュ一貫性
 * 非一様メモリアクセス（NUMA）
* トポロジー
 * インターコネクト
 * クラスタ
 * リソース共有（例：バスとインターコネクト）

**学習到達目標:**

[必修]

1. 共有メモリと分散メモリの違いを説明する。[知識]

[選択必修]

2. SMPアーキテクチャを説明し、その主な特徴を述べる。[知識]
3. SIMDマシンに自然にマッチするタスクの種類を特徴を述べる。[知識]


[選択科目]

4. GPUとCPUの長所と短所を説明する。[知識]
5. フリンの分類の各分類の特徴を説明する。[知識]
6. 不可分操作のためのアセンブリレベルの支援について説明する。[知識]
7. キャッシュの一貫性を維持する上での課題を説明する。[知識]
8. 異なるメモリと分散システムのトポロジーにおいて主な性能上の課題を説明する。[知識]



## PD/並列性能
*[選択科目]*

**トピック:**

* 負荷分散
* 性能測定
* スケジューリングと競合 (相互参照: [OS/スケジューリングとディスパッチ](./z_appendix_A_OS.md#osスケジューリングとディスパッチ))
* 通信オーバーヘッドの評価
* データ管理
 * 近接性によって異なる通信コスト (相互参照: [SF/近接と性能向上](./z_appendix_A_SF.md#sf近接と性能向上))
 * キャッシュの影響 (例: 偽共有)
 * 空間局在性の維持
* 電力使用量と管理



**学習到達目標:**

1. 不均一な負荷を検出し、修正する。[使用]
2. 特定の並列アルゴリズムに対するアムダールの法則の計算をする　(アムダールの法則については、[SF/性能評価] (./z_appendix_A_SF.md#sf性能評価)を参照)。[使用]
3. データの分布・配置がアルゴリズムの通信コストにどのように影響するか説明する。[知識]
4. 偽共有の事例を検出し、修正する。[使用]
5. スケジューリングが並列性能に与える影響を説明する。[知識]
6. データ局在性が性能に与える影響を説明する。[知識]
7. 並列性能に対して、電力使用に関する影響とトレードオフについて説明する。[知識]




## PD/分散システム
*[選択科目]*

**トピック:**

* 故障 (相互参照: [OS/耐故障性](./z_appendix_A_OS.md#os耐故障性))
 * ネットワークの故障 (分断を含む) とノードの故障
 * システム全体の保証 (例：可用性)への影響
* 分散メッセージ送信
 * データ変換と転送
 * ソケット
 * メッセージの順序付け
 * メッセージのバッファリング、再試行、ドロップ
* 分散システム設計のトレードオフ
 * レイテンシー vs スループット
 * 一貫性、可用性、分断耐性
* 分散サービス設計
 * ステートフル vs ステートレスのプロトコルとサービス
 * セッション (接続ベース) 設計
 * リアクティブ (IOトリガ) とマルチスレッド設計
* 分散アルゴリズム
 * 選出、発見

**学習到達目標:**

1. ネットワークの故障を他の種類の障害と区別する。[知識]
2. 分散環境において障害が発生する場合に、単純なロックのような同期構造がなぜ有用でないかを説明する。[知識]
3. 必要なマーシャリングとメッセージ単位への変換 (パケットなど) を行い、2つのホスト間で意味あるデータを通信するプログラムを作成する。[使用]
4. 与えられたネットワーク内のホスト間の、スループットと応答レイテンシーを測定する。[使用]
5. どの分散システムも同時に一貫性、可用性、および分断耐性を持つことはできないと説明する。[知識]
6. 単純なサーバーを実装する -- 例えば、スペルチェックサービス。[使用]
7. ステートフル vs ステートレス設計を選択する際のオーバーヘッド、スケーラビリティ、耐故障性のトレードオフを説明する。[知識]
8. サービスが成長し多くのクライアントに対応する際、または一時的に多くのクライアントを持つ際のスケーラビリティの課題を説明する。[知識]
9. リーダー選出などの合意アルゴリズムが必要となる問題の例を挙げる。[使用]



## PD/クラウドコンピューティング
*[選択科目]*

**トピック:**

* インターネットスケールの計算
 * タスクの分割 ([PD/並列アルゴリズム・解析とプログラミング](./z_appendix_A_PD.md#pd並列アルゴリズム解析とプログラミング))
 * データアクセス
 * クラスタ、グリッド、メッシュ
* クラウドサービス
 * IaaS (Infrastructure as a Service)
  * リソースの弾力性
  * プラットフォームAPI
 * SaaS (Software as a Service)
 * セキュリティ
 * コスト管理
* 仮想化 (相互参照: SF/仮想化と分離](./z_appendix_A_SF.md#sf仮想化と分離)、[OS/仮想マシン](./z_appendix_A_OS.md#os仮想マシン)）
 * 共有リソースの管理
 * プロセスのマイグレーション
* クラウド上のデータストレージ
 * 弱一貫性データストアへの共有アクセス
 * データ同期
 * データの分割
 * 分散ファイルシステム (相互参照: [IM/分散データベース](./z_appendix_A_IM.md#im分散データベース))
 * レプリケーション


**学習到達目標:**

1. クラウドコンピューティングにおける弾力性とリソース管理の重要性を議論する。[知識]
2. どのデバイスに対しても共有データの同じビューを提供するための同期戦略を説明する。[知識]
3. 仮想化インフラストラクチャの使用に関する利点と欠点を説明する。[知識]
4. クラウドインフラストラクチャ上に計算やデータリソースを使用するアプリケーションをデプロイする。[使用]
5. クライアントとリソース間でアプリケーションを適切に分割する。[使用]



## PD/形式モデルと意味論
*[選択科目]*

**トピック:**

* プロセスとメッセージパッシングの形式的モデル。Communicating Sequential Processes (CSP) やπ計算などの代数を含む
* 並列計算の形式的モデル。並列ランダムアクセス機械 (PRAM) とBulk Synchronous Parallel（BSP）などを含む
* 計算依存関係の形式的モデル
 * (緩和された) 共有メモリ一貫性のモデルとそのプログラミング言語仕様との関係
* 線形化可能性を含むアルゴリズムの正確性基準
* ノンブロッキング保証や公平性を含むアルゴリズム進行のモデル
* 不可分性や、データ競合が無いことなど、正確性に関する特性を記述し検証する技術

**学習到達目標:**

1. π計算などの形式的モデルを使用して並行プロセスをモデル化する。[使用]
2. 特定の形式的並列モデルの特性を説明する。[知識]
3. 共有メモリシステムに対して一貫性があるかを示すために形式的モデルを使用する。[使用]
4. 並列アルゴリズムの進行保証を示すためのモデルを使用する。[使用]
5. 安全性または生存性の観点で並列アルゴリズムが正しいことを示すための形式的技術を使用する。[使用]
6. 特定の実行が線形化可能かどうかを判断する。[使用]
